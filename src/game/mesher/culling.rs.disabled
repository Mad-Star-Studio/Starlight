use bevy::{asset::RenderAssetUsages, prelude::Mesh, render::mesh::Indices};

use super::{VoxelAtom, VoxelMesh, VoxelMeshManager, VoxelMeshManagerDataSource};
const CUBE_SIZE: usize = 16;

pub struct VoxelCullingMesh {
    mesh: Mesh
}

impl VoxelMesh for VoxelCullingMesh {
    fn get_mesh(&self) -> &bevy::prelude::Mesh {
        todo!()
    }

    fn regenerate_mesh(&mut self) {   // Create a Minecraft-style voxel mesh from the data
        let mut vertices: Vec<[f32; 3]> = Vec::new();
        let mut indices: Vec<u32> = Vec::new();
        let mut normals: Vec<[f32; 3]> = Vec::new();
        let mut uvs: Vec<[f32; 2]> = Vec::new();
        let mut vertex_colors: Vec<[f32; 4]> = Vec::new();
    
        let face_verts = [
            // Mind backface culling!
            // Front face
            [
                [0.0, 0.0, 0.0],
                [1.0, 0.0, 0.0],
                [1.0, 1.0, 0.0],
                [0.0, 1.0, 0.0],
            ],
            // Back face
            [
                [1.0, 0.0, 1.0],
                [0.0, 0.0, 1.0],
                [0.0, 1.0, 1.0],
                [1.0, 1.0, 1.0],
            ],
            // Top face
            [
                [0.0, 1.0, 0.0],
                [1.0, 1.0, 0.0],
                [1.0, 1.0, 1.0],
                [0.0, 1.0, 1.0],
            ],
            // Bottom face
            [
                [0.0, 0.0, 1.0],
                [1.0, 0.0, 1.0],
                [1.0, 0.0, 0.0],
                [0.0, 0.0, 0.0],
            ],
            // Right face
            [
                [1.0, 0.0, 0.0],
                [1.0, 0.0, 1.0],
                [1.0, 1.0, 1.0],
                [1.0, 1.0, 0.0],
            ],
            // Left face
            [
                [0.0, 0.0, 1.0],
                [0.0, 0.0, 0.0],
                [0.0, 1.0, 0.0],
                [0.0, 1.0, 1.0],
            ],
        ];
    
        // Add vertices and indices to the mesh to create faces, and don't add faces for block faces that are touching other blocks
        let mut x = 0;
        let mut y = 0;
        let mut z = 0;
    
        while z < CUBE_SIZE {
            if self.data[x][y][z].id != 0 {
                for i in 0..6 {
                    // Identify if the face is touching another block - If so, `continue` to skip adding the face
                    let mut touching = false;
    
                    match i {
                        5 => {
                            if x > 0 && self.data[x - 1][y][z].id != 0 {
                                touching = true;
                            }
                        }
                        4 => {
                            if x < 7 && self.data[x + 1][y][z].id != 0 {
                                touching = true;
                            }
                        }
                        3 => {
                            if y > 0 && self.data[x][y - 1][z].id != 0 {
                                touching = true;
                            }
                        }
                        2 => {
                            if y < 7 && self.data[x][y][z].id != 0 {
                                touching = true;
                            }
                        }
                        0 => {
                            if z > 0 && self.data[x][y][z - 1].id != 0 {
                                touching = true;
                            }
                        }
                        1 => {
                            if z < 7 && self.data[x][y][z + 1].id != 0 {
                                touching = true;
                            }
                        }
                        _ => {}
                    }
    
                    if touching {
                        continue;
                    }
    
                    // Add positions
                    for j in 0..4 {
                        vertices.push([
                            x as f32 + face_verts[i][j][0],
                            y as f32 + face_verts[i][j][1],
                            z as f32 + face_verts[i][j][2],
                        ]);
                    }
    
                    // Add indices
                    let index_offset = vertices.len() as u32 - 4;
                    indices.push(index_offset + 2);
                    indices.push(index_offset + 1);
                    indices.push(index_offset);
                    indices.push(index_offset + 3);
                    indices.push(index_offset + 2);
                    indices.push(index_offset);
    
                    // Add UVs and colors
                    uvs.push([0.0, 0.0]);
                    uvs.push([1.0, 0.0]);
                    uvs.push([1.0, 1.0]);
                    uvs.push([0.0, 1.0]);
                    vertex_colors.push([0.0, 0.0, 0.0, 1.0]);
                    vertex_colors.push([10.0, 0.0, 0.0, 1.0]);
                    vertex_colors.push([0.0, 10.0, 0.0, 1.0]);
                    vertex_colors.push([10.0, 10.0, 0.0, 1.0]);
                }
            }
    
            // Manage the loop
            x += 1;
            if x == CUBE_SIZE {
                x = 0;
                y += 1;
                if y == CUBE_SIZE {
                    y = 0;
                    z += 1;
                }
            }
        }
        self.mesh = Mesh::new(bevy::render::mesh::PrimitiveTopology::TriangleList,
        RenderAssetUsages::default())
        .with_inserted_attribute(Mesh::ATTRIBUTE_COLOR, vertex_colors)
        .with_inserted_attribute(Mesh::ATTRIBUTE_UV_0, uvs.clone())
        .with_inserted_attribute(Mesh::ATTRIBUTE_UV_1, uvs)
        .with_inserted_attribute(Mesh::ATTRIBUTE_POSITION, vertices)
        .with_inserted_indices(Indices::U32(indices));
    
        // mesh.generate_tangents();
    }
}

pub struct VoxelCullingMesherManager<'a, DS: VoxelMeshManagerDataSource<'a>> {
    data_source: &'a DS,
}

impl<'a, DS: VoxelMeshManagerDataSource<'a>> VoxelCullingMesherManager<'a, DS> {
    pub fn new(data_source: &'a DS) -> Self {
        Self {
            data_source
        }
    }
}

impl<'a, DS: VoxelMeshManagerDataSource<'a>> VoxelMeshManager<VoxelCullingMesh> for VoxelCullingMesherManager<'a, DS> {
    fn create_mesh(&self, at: (i32, i32, i32)) -> VoxelCullingMesh {
        let data = self.data_source.get_chunk_data(at.0, at.1, at.2);

        VoxelCullingMesh {
            mesh: Mesh::new(bevy::render::mesh::PrimitiveTopology::TriangleList, RenderAssetUsages::default()),
            data
        }
    }
}